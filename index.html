<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>ğŸŒŒ Neon Odyssey: AI Generated Worlds</title>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Cairo:wght@400;700;900&display=swap');
    
    :root {
        --primary: #00f3ff;
        --accent: #ff0055;
        --bg: #050510;
        --glass: rgba(20, 25, 40, 0.9);
    }
    
    body {
        margin: 0; overflow: hidden; background: var(--bg);
        color: #fff; font-family: 'Cairo', sans-serif;
        height: 100vh; display: flex; align-items: center; justify-content: center;
    }

    /* --- UI Layer --- */
    #ui-layer {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        pointer-events: none; z-index: 10; display: flex; flex-direction: column;
    }

    /* Screens (Login, Story, Game Over) */
    .screen {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.92); backdrop-filter: blur(10px);
        display: flex; flex-direction: column; align-items: center; justify-content: center;
        z-index: 20; pointer-events: auto; transition: opacity 0.5s;
    }
    .hidden { opacity: 0; pointer-events: none; }
    
    .panel {
        background: var(--glass); border: 1px solid var(--primary);
        padding: 30px; border-radius: 20px; width: 90%; max-width: 500px;
        text-align: center; box-shadow: 0 0 30px rgba(0, 243, 255, 0.15);
        position: relative; overflow: hidden;
    }
    .panel::before {
        content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 4px;
        background: linear-gradient(90deg, var(--primary), var(--accent));
    }

    h1, h2 { margin: 0 0 15px; text-transform: uppercase; letter-spacing: 2px; }
    h1 { color: var(--primary); font-size: 2rem; }
    p { color: #ccc; line-height: 1.6; margin-bottom: 20px; font-size: 1.1rem; }

    input {
        width: 100%; padding: 15px; background: #0a0a15; border: 1px solid #333;
        color: #fff; border-radius: 8px; font-family: inherit; margin-bottom: 15px;
        text-align: center; direction: ltr; font-size: 1rem;
    }
    
    button {
        background: var(--primary); color: #000; border: none; padding: 15px 40px;
        font-size: 1.2rem; font-weight: 900; border-radius: 8px; cursor: pointer;
        transition: 0.3s; width: 100%; clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
    }
    button:hover { transform: translateY(-3px); box-shadow: 0 10px 20px rgba(0, 243, 255, 0.3); }
    button.secondary { background: transparent; border: 2px solid #333; color: #888; margin-top: 10px; }

    /* Loading / AI Generation */
    .loader {
        border: 4px solid #111; border-top: 4px solid var(--primary);
        border-radius: 50%; width: 40px; height: 40px;
        animation: spin 1s linear infinite; margin: 20px auto;
    }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

    /* In-Game HUD */
    .hud {
        padding: 20px; display: flex; justify-content: space-between; align-items: flex-start;
        text-shadow: 0 2px 4px #000;
    }
    .stat { background: rgba(0,0,0,0.5); padding: 5px 15px; border-radius: 20px; border: 1px solid rgba(255,255,255,0.1); }
    .stat span { color: var(--primary); font-weight: bold; font-size: 1.2rem; }
    
    #level-title {
        position: absolute; top: 15%; width: 100%; text-align: center;
        font-size: 3rem; font-weight: 900; color: #fff; opacity: 0;
        text-shadow: 0 0 20px var(--primary); pointer-events: none;
        transition: 0.5s; transform: scale(0.8);
    }
    .show-title { opacity: 1 !important; transform: scale(1) !important; }

    /* Canvas */
    canvas {
        width: 100%; height: 100%; object-fit: cover;
    }

    /* Touch Controls */
    .touch-zone {
        position: absolute; bottom: 0; height: 100%; width: 50%; z-index: 5;
    }
    #t-left { left: 0; } #t-right { right: 0; }

</style>
</head>
<body>

    <!-- Game World -->
    <canvas id="c"></canvas>
    
    <div id="ui-layer">
        <!-- HUD -->
        <div class="hud" id="hud" style="opacity:0">
            <div>
                <div class="stat">Ø§Ù„Ù…Ø±Ø­Ù„Ø©: <span id="lvl-display">1</span></div>
                <div class="stat" style="margin-top:5px">Ø§Ù„ØªÙ‚Ø¯Ù…: <span id="dist-display">0%</span></div>
            </div>
            <div class="stat">Ø§Ù„Ø¯Ø±Ø¹: <span id="hp-display" style="color:var(--accent)">100%</span></div>
        </div>

        <!-- Dramatic Level Title -->
        <h1 id="level-title">SYSTEM READY</h1>

        <!-- Touch Controls -->
        <div class="touch-zone" id="t-left"></div>
        <div class="touch-zone" id="t-right"></div>
    </div>

    <!-- 1. API Key Screen -->
    <div id="screen-login" class="screen">
        <div class="panel">
            <h1>Neon Odyssey</h1>
            <p>Ù„Ø¹Ø¨Ø© Ø³Ø¨Ø§Ù‚ Ù…ØªÙˆÙ„Ø¯Ø© Ø°Ø§ØªÙŠØ§Ù‹ (Procedural AI).<br>ÙƒÙ„ Ù…Ø±Ø­Ù„Ø© ÙŠØµÙ…Ù…Ù‡Ø§ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ø®ØµÙŠØµØ§Ù‹ Ù„Ùƒ.</p>
            <input type="password" id="api-key" placeholder="Ø£Ù„ØµÙ‚ Ù…ÙØªØ§Ø­ Gemini API Ù‡Ù†Ø§">
            <button onclick="Auth.save()">Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ù†Ø¸Ø§Ù…</button>
            <p style="font-size:0.8rem; margin-top:15px; opacity:0.5">ÙŠØªÙ… Ø­ÙØ¸ Ø§Ù„Ù…ÙØªØ§Ø­ Ù…Ø­Ù„ÙŠØ§Ù‹ ÙÙŠ Ø¬Ù‡Ø§Ø²Ùƒ ÙÙ‚Ø·.</p>
        </div>
    </div>

    <!-- 2. Story / Loading Screen -->
    <div id="screen-story" class="screen hidden">
        <div class="panel">
            <h2 id="story-title" style="color:var(--primary)">Ø¬Ø§Ø±ÙŠ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª...</h2>
            <p id="story-text">ÙŠÙ‚ÙˆÙ… Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ø¨Ø¨Ù†Ø§Ø¡ Ø§Ù„Ø¹Ø§Ù„Ù… Ø§Ù„Ø¢Ù†...</p>
            
            <div id="ai-loading" class="loader"></div>
            
            <div id="story-actions" class="hidden">
                <button onclick="Game.startLevel()">Ø§Ø¨Ø¯Ø£ Ø§Ù„Ù…Ù‡Ù…Ø©</button>
            </div>
        </div>
    </div>

    <!-- 3. Game Over Screen -->
    <div id="screen-over" class="screen hidden">
        <div class="panel">
            <h2 style="color:var(--accent)">ØªØ­Ø·Ù…Øª Ø§Ù„Ù…Ø±ÙƒØ¨Ø©</h2>
            <p id="death-reason">Ø§Ù†ØªÙ‡Øª Ø§Ù„Ø±Ø­Ù„Ø©.</p>
            <button onclick="Game.resetCampaign()">Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ´ØºÙŠÙ„</button>
        </div>
    </div>

<script>
(function() {
/*
 * SYSTEM ARCHITECTURE
 * 1. AI Service: Handles Gemini API calls & JSON parsing.
 * 2. Level Manager: Interprets JSON to set physics, colors, and rules.
 * 3. Game Engine: Rendering, Physics, Loop.
 * 4. UI/Auth: Manages screens and persistence.
 */

/* --- 1. AI Service --- */
const AI = {
    key: null,
    
    // Ø§Ù„ØªÙ„Ù‚ÙŠÙ† (Prompt) Ø§Ù„Ø°ÙŠ ÙŠØ¬Ø¨Ø± Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ Ø¹Ù„Ù‰ ØªØµÙ…ÙŠÙ… Ù…Ø±Ø­Ù„Ø©
    generateLevelPrompt: (levelNum, hp) => `
    Context: You are the Game Director for a Cyberpunk racing game.
    Current State: Player is at Level ${levelNum}, Health ${hp}%.
    Task: Generate the next level parameters in valid JSON format ONLY.
    
    Requirements:
    1. "theme_name": Creative Arabic title (e.g., "ØµØ­Ø±Ø§Ø¡ Ø§Ù„Ù†ÙŠÙˆÙ†", "Ø§Ù„Ù†ÙÙ‚ Ø§Ù„Ù…Ø¸Ù„Ù…").
    2. "intro_text": 2 sentences in Arabic setting the scene (e.g., "Detected slippery roads ahead.").
    3. "colors": Hex codes for "road", "sky", "lines", "obstacle".
    4. "physics":
       - "speed_mult": 1.0 to 1.8 (float)
       - "friction": 0.85 (slippery) to 0.98 (grippy)
       - "visibility": 0 to 1 (1 is clear, 0.3 is foggy)
    5. "level_length": 3000 to 8000 (meters).
    6. "density": 0.5 to 2.0 (obstacle spawn rate).

    Output Example:
    {
      "theme_name": "Ø§Ù„Ø¹Ø§ØµÙØ© Ø§Ù„Ø±Ù‚Ù…ÙŠØ©",
      "intro_text": "Ø§Ø­Ø°Ø±ØŒ Ø§Ù„Ø·Ø±ÙŠÙ‚ Ø²Ù„Ù‚ Ù„Ù„ØºØ§ÙŠØ© ÙˆØ§Ù„Ø±Ø¤ÙŠØ© Ù…Ø¹Ø¯ÙˆÙ…Ø©.",
      "colors": {"road": "#222", "sky": "#000", "lines": "#0f0", "obstacle": "#f00"},
      "physics": {"speed_mult": 1.2, "friction": 0.9, "visibility": 0.5},
      "level_length": 4000,
      "density": 1.2
    }
    `,

    async fetchNextLevel(levelNum, hp) {
        const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${this.key}`;
        
        try {
            const response = await fetch(url, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    contents: [{ parts: [{ text: this.generateLevelPrompt(levelNum, hp) }] }],
                    generationConfig: { responseMimeType: "application/json" }
                })
            });
            const data = await response.json();
            const text = data.candidates[0].content.parts[0].text;
            return JSON.parse(text); // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†Øµ Ø¥Ù„Ù‰ ÙƒØ§Ø¦Ù† Ø¨Ø±Ù…Ø¬ÙŠ
        } catch (e) {
            console.error("AI Generation Failed", e);
            // Fallback level in case of error
            return {
                theme_name: "ÙˆØ¶Ø¹ Ø§Ù„Ø·ÙˆØ§Ø±Ø¦",
                intro_text: "ÙÙ‚Ø¯Ù†Ø§ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø®Ø§Ø¯Ù…. Ù‚Ù… Ø¨Ø§Ù„Ù‚ÙŠØ§Ø¯Ø© ÙŠØ¯ÙˆÙŠØ§Ù‹.",
                colors: {road: "#111", sky: "#050510", lines: "#fff", obstacle: "#f00"},
                physics: {speed_mult: 1, friction: 0.95, visibility: 1},
                level_length: 3000,
                density: 1
            };
        }
    }
};

/* --- 2. Auth & UI --- */
const Auth = {
    init() {
        const key = localStorage.getItem('gemini_key');
        if (key) {
            AI.key = key;
            document.getElementById('screen-login').classList.add('hidden');
            Game.initCampaign();
        }
    },
    save() {
        const input = document.getElementById('api-key').value.trim();
        if (input.length < 10) return alert('Ù…ÙØªØ§Ø­ ØºÙŠØ± ØµØ­ÙŠØ­');
        localStorage.setItem('gemini_key', input);
        AI.key = input;
        document.getElementById('screen-login').classList.add('hidden');
        Game.initCampaign();
    },
    reset() {
        localStorage.removeItem('gemini_key');
        location.reload();
    }
};

// Expose Auth to global scope for HTML onclick events
window.Auth = Auth;

/* --- 3. Game Engine --- */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H, scale;

const Game = {
    level: 1,
    hp: 100,
    state: 'MENU', // MENU, LOADING, PLAYING, GAMEOVER
    currentLevelData: null,
    
    // Physics & World
    lanes: [],
    player: { x: 0, y: 0, w: 50, h: 90, lane: 1, targetX: 0 },
    obstacles: [],
    particles: [],
    speed: 0,
    distance: 0,
    globalSpeed: 0, // Road scroll speed
    
    resize() {
        W = canvas.width = window.innerWidth;
        H = canvas.height = window.innerHeight;
        scale = Math.min(W/480, 1);
        Game.lanes = [W*0.25, W*0.5, W*0.75]; // 3 Lanes
    },

    initCampaign() {
        Game.level = 1;
        Game.hp = 100;
        Game.loadNextLevel();
    },

    async loadNextLevel() {
        Game.state = 'LOADING';
        
        // UI Setup
        const storyScreen = document.getElementById('screen-story');
        storyScreen.classList.remove('hidden');
        document.getElementById('ai-loading').style.display = 'block';
        document.getElementById('story-actions').classList.add('hidden');
        document.getElementById('story-title').innerText = `ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø±Ø­Ù„Ø© ${Game.level}`;
        document.getElementById('story-text').innerText = "Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ù‚Ù…Ø± Ø§Ù„ØµÙ†Ø§Ø¹ÙŠ Ù„ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØªØ¶Ø§Ø±ÙŠØ³...";

        // Call AI
        const levelData = await AI.fetchNextLevel(Game.level, Game.hp);
        Game.currentLevelData = levelData;

        // Apply Data
        document.getElementById('story-title').innerText = levelData.theme_name;
        document.getElementById('story-text').innerText = levelData.intro_text;
        document.getElementById('ai-loading').style.display = 'none';
        document.getElementById('story-actions').classList.remove('hidden');
        
        // Reset Game State for new level
        Game.distance = 0;
        Game.speed = 0;
        Game.obstacles = [];
        Game.player.lane = 1;
        Game.player.targetX = Game.lanes[1];
        Game.player.x = Game.lanes[1];
    },

    startLevel() {
        document.getElementById('screen-story').classList.add('hidden');
        document.getElementById('hud').style.opacity = 1;
        
        // Show Title Animation
        const titleEl = document.getElementById('level-title');
        titleEl.innerText = Game.currentLevelData.theme_name;
        titleEl.style.color = Game.currentLevelData.colors.lines;
        titleEl.classList.add('show-title');
        setTimeout(() => titleEl.classList.remove('show-title'), 3000);

        Game.state = 'PLAYING';
        Game.loop();
    },

    resetCampaign() {
        document.getElementById('screen-over').classList.add('hidden');
        Game.initCampaign();
    },

    move(dir) {
        if (Game.state !== 'PLAYING') return;
        const next = Game.player.lane + dir;
        if (next >= 0 && next < Game.lanes.length) {
            Game.player.lane = next;
            Game.player.targetX = Game.lanes[next];
        }
    },

    // --- MAIN LOOP ---
    loop() {
        if (Game.state !== 'PLAYING') return;

        // 1. Update Physics
        const physics = Game.currentLevelData.physics;
        
        // Accelerate
        const maxSpeed = 20 * physics.speed_mult;
        if (Game.speed < maxSpeed) Game.speed += 0.1;
        Game.globalSpeed = Game.speed * 2; // For scrolling
        Game.distance += Game.globalSpeed * 0.1;

        // Player Movement (Lerp for friction feel)
        Game.player.x += (Game.player.targetX - Game.player.x) * (1 - physics.friction + 0.05);

        // Spawn Obstacles
        const density = Game.currentLevelData.density;
        if (Math.random() < 0.02 * density) {
            Game.obstacles.push({
                lane: Math.floor(Math.random() * 3),
                y: -100,
                type: Math.random() > 0.8 ? 'block' : 'car'
            });
        }

        // Update Obstacles
        for (let i = Game.obstacles.length - 1; i >= 0; i--) {
            let o = Game.obstacles[i];
            o.y += Game.globalSpeed * 0.8; // Move down
            o.x = Game.lanes[o.lane];

            // Collision
            if (Math.abs(o.y - (H - 150)) < 60 && Math.abs(o.x - Game.player.x) < 40) {
                Game.hp -= 20;
                Game.speed *= 0.5;
                Game.createParticles(o.x, o.y, Game.currentLevelData.colors.obstacle);
                Game.obstacles.splice(i, 1);
                
                // Shake Effect
                document.body.style.transform = `translate(${Math.random()*10-5}px, ${Math.random()*10-5}px)`;
                setTimeout(()=>document.body.style.transform='none', 200);

                if (Game.hp <= 0) {
                    Game.state = 'GAMEOVER';
                    document.getElementById('screen-over').classList.remove('hidden');
                    document.getElementById('death-reason').innerText = `ÙˆØµÙ„Øª Ù„Ù„Ù…Ø±Ø­Ù„Ø© ${Game.level} - ${Game.currentLevelData.theme_name}`;
                }
            }

            if (o.y > H) Game.obstacles.splice(i, 1);
        }

        // Check Win Condition
        const progress = Math.min(100, (Game.distance / Game.currentLevelData.level_length) * 100);
        document.getElementById('dist-display').innerText = Math.floor(progress) + '%';
        
        if (Game.distance >= Game.currentLevelData.level_length) {
            Game.level++;
            Game.loadNextLevel();
            return;
        }

        // 2. Render
        Game.draw();

        requestAnimationFrame(Game.loop);
    },

    draw() {
        const colors = Game.currentLevelData.colors;
        const phys = Game.currentLevelData.physics;

        // Clear & Background
        ctx.fillStyle = colors.sky;
        ctx.fillRect(0, 0, W, H);

        // Road with Perspective
        ctx.fillStyle = colors.road;
        const roadW = W * 0.9;
        const roadX = (W - roadW) / 2;
        ctx.fillRect(roadX, 0, roadW, H);

        // Moving Grid / Lines
        ctx.strokeStyle = colors.lines;
        ctx.lineWidth = 2;
        ctx.shadowBlur = 10;
        ctx.shadowColor = colors.lines;

        let offset = (Date.now() * Game.speed * 0.1) % 100;
        
        // Vertical Lanes
        Game.lanes.forEach(x => {
            ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
        });

        // Horizontal Grid (Retro effect)
        for(let i=0; i<H; i+=80) {
            let y = (i + offset) % H;
            ctx.globalAlpha = (y / H); // Fade at top
            ctx.beginPath(); ctx.moveTo(roadX, y); ctx.lineTo(roadX+roadW, y); ctx.stroke();
        }
        ctx.globalAlpha = 1;

        // Player
        ctx.shadowColor = varPrimary;
        ctx.fillStyle = '#000';
        ctx.strokeStyle = varPrimary;
        const px = Game.player.x;
        const py = H - 150;
        
        // Neon Car
        ctx.beginPath();
        ctx.moveTo(px, py);
        ctx.lineTo(px - 20, py + 80); // Left Back
        ctx.lineTo(px + 20, py + 80); // Right Back
        ctx.closePath();
        ctx.fill(); ctx.stroke();
        
        // Engine Flame
        if(Math.random() > 0.5) {
            ctx.fillStyle = varAccent;
            ctx.fillRect(px - 5, py + 80, 10, Math.random() * 20);
        }

        // Obstacles
        Game.obstacles.forEach(o => {
            ctx.fillStyle = colors.obstacle;
            ctx.shadowColor = colors.obstacle;
            if (o.type === 'block') {
                ctx.fillRect(o.x - 25, o.y, 50, 50);
            } else {
                ctx.beginPath(); ctx.moveTo(o.x, o.y+60); ctx.lineTo(o.x-20, o.y); ctx.lineTo(o.x+20, o.y); ctx.fill();
            }
        });

        // Particles
        Game.particles.forEach((p, i) => {
            p.x += p.vx; p.y += p.vy; p.life -= 0.05;
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            ctx.fillRect(p.x, p.y, 4, 4);
            if(p.life <=0) Game.particles.splice(i, 1);
        });
        ctx.globalAlpha = 1;

        // Fog / Visibility
        if (phys.visibility < 1) {
            const grad = ctx.createLinearGradient(0, 0, 0, H);
            grad.addColorStop(0, colors.sky);
            grad.addColorStop(phys.visibility, "transparent");
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,W,H);
        }
        
        // HUD Updates
        document.getElementById('lvl-display').innerText = Game.level;
        document.getElementById('hp-display').innerText = Game.hp + '%';
        document.getElementById('hp-display').style.color = Game.hp < 30 ? '#f00' : '#0f0';
    },

    createParticles(x, y, color) {
        for(let i=0; i<15; i++) {
            Game.particles.push({
                x: x, y: y,
                vx: (Math.random() - 0.5) * 10,
                vy: (Math.random() - 0.5) * 10,
                life: 1.0, color: color
            });
        }
    }
};

// Expose Game to global scope
window.Game = Game;

// --- Inputs ---
window.addEventListener('resize', Game.resize);
Game.resize();

const varPrimary = getComputedStyle(document.body).getPropertyValue('--primary').trim();
const varAccent = getComputedStyle(document.body).getPropertyValue('--accent').trim();

document.addEventListener('keydown', e => {
    if (e.key === 'ArrowLeft') Game.move(-1);
    if (e.key === 'ArrowRight') Game.move(1);
});

document.getElementById('t-left').addEventListener('touchstart', (e) => { e.preventDefault(); Game.move(-1); });
document.getElementById('t-right').addEventListener('touchstart', (e) => { e.preventDefault(); Game.move(1); });

Auth.init();
})();
</script>
</body>
</html>